"""
This type stub file was generated by pyright.
"""

from typing import Dict, Literal, TypedDict
from urllib.request import Request
from typing_extensions import NotRequired
from speech_recognition.audio import AudioData

class Alternative(TypedDict):
    transcript: str
    confidence: float
    ...


class Result(TypedDict):
    alternative: list[Alternative]
    final: bool
    ...


class GoogleResponse(TypedDict):
    result: list[Result]
    result_index: NotRequired[int]
    ...


ProfanityFilterLevel = Literal[0, 1]
RequestHeaders = Dict[str, str]
ENDPOINT = ...
class RequestBuilder:
    def __init__(self, *, endpoint: str, key: str, language: str, filter_level: ProfanityFilterLevel) -> None:
        ...
    
    def build(self, audio_data: AudioData) -> Request:
        ...
    
    def build_url(self) -> str:
        """
        >>> builder = RequestBuilder(endpoint="http://www.google.com/speech-api/v2/recognize", key="awesome-key", language="en-US", filter_level=0)
        >>> builder.build_url()
        'http://www.google.com/speech-api/v2/recognize?client=chromium&lang=en-US&key=awesome-key&pFilter=0'
        """
        ...
    
    def build_headers(self, audio_data: AudioData) -> RequestHeaders:
        """
        >>> builder = RequestBuilder(endpoint="", key="", language="", filter_level=1)
        >>> audio_data = AudioData(b"", 16_000, 1)
        >>> builder.build_headers(audio_data)
        {'Content-Type': 'audio/x-flac; rate=16000'}
        """
        ...
    
    def build_data(self, audio_data: AudioData) -> bytes:
        ...
    
    @staticmethod
    def to_convert_rate(sample_rate: int) -> int:
        """Audio samples must be at least 8 kHz

        >>> RequestBuilder.to_convert_rate(16_000)
        >>> RequestBuilder.to_convert_rate(8_000)
        >>> RequestBuilder.to_convert_rate(7_999)
        8000
        """
        ...
    


def create_request_builder(*, endpoint: str, key: str | None = ..., language: str = ..., filter_level: ProfanityFilterLevel = ...) -> RequestBuilder:
    ...

class OutputParser:
    def __init__(self, *, show_all: bool, with_confidence: bool) -> None:
        ...
    
    def parse(self, response_text: str): # -> Result | tuple[str, float] | str:
        ...
    
    @staticmethod
    def convert_to_result(response_text: str) -> Result:
        r"""
        >>> response_text = '''{"result":[]}
        ... {"result":[{"alternative":[{"transcript":"one two three","confidence":0.49585345},{"transcript":"1 2","confidence":0.42899391}],"final":true}],"result_index":0}
        ... '''
        >>> OutputParser.convert_to_result(response_text)
        {'alternative': [{'transcript': 'one two three', 'confidence': 0.49585345}, {'transcript': '1 2', 'confidence': 0.42899391}], 'final': True}

        >>> OutputParser.convert_to_result("")
        Traceback (most recent call last):
          ...
        speech_recognition.exceptions.UnknownValueError
        >>> OutputParser.convert_to_result('\n{"result":[]}')
        Traceback (most recent call last):
          ...
        speech_recognition.exceptions.UnknownValueError
        >>> OutputParser.convert_to_result('{"result":[{"foo": "bar"}]}')
        Traceback (most recent call last):
          ...
        speech_recognition.exceptions.UnknownValueError
        >>> OutputParser.convert_to_result('{"result":[{"alternative": []}]}')
        Traceback (most recent call last):
          ...
        speech_recognition.exceptions.UnknownValueError
        """
        ...
    
    @staticmethod
    def find_best_hypothesis(alternatives: list[Alternative]) -> Alternative:
        """
        >>> alternatives = [{"transcript": "one two three", "confidence": 0.42899391}, {"transcript": "1 2", "confidence": 0.49585345}]
        >>> OutputParser.find_best_hypothesis(alternatives)
        {'transcript': 'one two three', 'confidence': 0.42899391}

        >>> alternatives = [{"confidence": 0.49585345}]
        >>> OutputParser.find_best_hypothesis(alternatives)
        Traceback (most recent call last):
          ...
        speech_recognition.exceptions.UnknownValueError
        """
        ...
    


def obtain_transcription(request: Request, timeout: int) -> str:
    ...

def recognize_legacy(recognizer, audio_data: AudioData, key: str | None = ..., language: str = ..., pfilter: ProfanityFilterLevel = ..., show_all: bool = ..., with_confidence: bool = ..., *, endpoint: str = ...): # -> Result | tuple[str, float] | str:
    """Performs speech recognition on ``audio_data`` (an ``AudioData`` instance), using the Google Speech Recognition API.

    The Google Speech Recognition API key is specified by ``key``. If not specified, it uses a generic key that works out of the box. This should generally be used for personal or testing purposes only, as it **may be revoked by Google at any time**.

    To obtain your own API key, simply following the steps on the `API Keys <http://www.chromium.org/developers/how-tos/api-keys>`__ page at the Chromium Developers site. In the Google Developers Console, Google Speech Recognition is listed as "Speech API".

    The recognition language is determined by ``language``, an RFC5646 language tag like ``"en-US"`` (US English) or ``"fr-FR"`` (International French), defaulting to US English. A list of supported language tags can be found in this `StackOverflow answer <http://stackoverflow.com/a/14302134>`__.

    The profanity filter level can be adjusted with ``pfilter``: 0 - No filter, 1 - Only shows the first character and replaces the rest with asterisks. The default is level 0.

    Returns the most likely transcription if ``show_all`` is false (the default). Otherwise, returns the raw API response as a JSON dictionary.

    Raises a ``speech_recognition.UnknownValueError`` exception if the speech is unintelligible. Raises a ``speech_recognition.RequestError`` exception if the speech recognition operation failed, if the key isn't valid, or if there is no internet connection.
    """
    ...